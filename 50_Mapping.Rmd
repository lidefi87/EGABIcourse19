# Mapeo

## Mapas en R

El paquete de mapeo general más antiguo y esencial en R es el paquete `maps`. Contiene un conjunto de datos simple de límites costeros de todo el mundo listos para usar.


```{r maps-package}
maps::map()
```

Los datos subyacentes de este mapa en vivo están disponibles al capturar la salida como un objeto real. Observa que la línea costera de la Antártida no se extiende hasta el polo sur y que partes de Rusia al este del meridiano 180 no aparecen en la parte occidental del mapa.

```{r maps-assign}
m <- maps::map(plot = FALSE)

lonlat <- cbind(m$x, m$y)

plot(lonlat, pch = "+", cex = 0.4, axes = FALSE)
lines(lonlat, col = "dodgerblue")

abline(h = c(-90, 90), v = c(-180, 180))

```

Un conjunto de datos muy similar y más moderno está disponible en el paquete `maptools`.

```{r wrld-simpl}
data("wrld_simpl", package = "maptools")
library(sp)
plot(wrld_simpl)
```

Este conjunto de datos se alinea exactamente con la extensión convencional de -180/180 -90/90 para la proyección de longitud/latitud.

```{r lon180-lat90}
plot(0, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-180, 180), ylim = c(-90, 90))
rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = "darkred", lwd = 4, lty = 2)
plot(wrld_simpl, add = TRUE)
```

### Ejercicios

1. ¿Cómo podemos encontrar los rangos de longitud y latitud de los datos de mapas `m` y los datos de `wrld_simpl` de maptools?? 
2. ¿Podemos dibujar polígonos con un color de relleno con el paquete? 


Respuesta 1: `range(m$x, na.rm = TRUE)` `range(m$y, na.rm = TRUE`) y `m$range`

Respuesta 2: `polygon(lonlat, col = "grey")` no funciona, y `map(mp, fill = TRUE, col = "grey")` tampoco funciona, pero `maps::map(fill = TRUE, col = "grey")` parece funcionar.


¿Qué está pasando? Mira la esquina sureste del mapa. La línea de la costa se ha extendido hasta el límite sur del área disponible.


```{r south-east}
plot(0, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-150, 180), ylim = c(-90, -60))
plot(wrld_simpl, add = TRUE, col = "grey")
rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = "darkred", lwd = 4, lty = 2)

maps::map(add = TRUE, col = "dodgerblue", lwd = 3)
```

Cuando agregamos la antigua línea de la costa de los mapas, vemos que no se extiende hasta 90S y no atraviesa el límite sur.

Una razón para esto es que si elegimos una proyección donde los bordes este y oeste de la línea de costa de la Antártida se encuentren, obtenemos una unión que parece bastante limpia.

```{r laea}
## scale factor
f <- 3e6
plot(rgdal::project(lonlat, "+proj=laea +lat_0=-90 +datum=WGS84"), asp = 1, type = "l",
     xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = "", ylab = "")

```

Si intentamos lo mismo con `wrld_simpl` la unión no es tan limpia.  Tenemos una extraña "costura" que apunta exactamente al polo sur (nuestra proyección está centrada en longitud = 0 y latitud = -90).

```{r wrld}
plot(sp::spTransform(wrld_simpl, "+proj=laea +lat_0=-90 +datum=WGS84"), asp = 1,
     xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = "", ylab = "", lwd = 3)
abline(v = 0, h = 0, lty = 2, col = "grey")
```


### ¡Usemos los datos de mapas!

En m, tenemos la estructura de datos de mapas, y parece prometedor.

```{r maps-data}
str(m)

mp <- m
pxy <- rgdal::project(lonlat, "+proj=laea +lat_0=-90 +datum=WGS84")
mp$x <- pxy[,1]
mp$y <- pxy[,2]
mp$range <- c(range(mp$x,na.rm = TRUE), range(mp$y, na.rm = TRUE))
mp$range
plot(c(-1, 1) * f, c(-1, 1) * f, type = "n", asp = 1)
maps::map(mp, add = TRUE)


## pero no se necesita mucho para que algo salga mal
plot(c(-1, 1) * f, c(-1, 1) * f, type = "n", asp = 1)
maps::map(mp, add = TRUE, fill = TRUE, col = "grey")

```

El problema es que la base de datos de mapas tiene suficiente estructura interna para unir líneas correctamente, con brechas `NA` entre diferentes cadenas de líneas conectadas, pero no lo suficiente como para dibujar estas cosas como polígonos. Ocurre un problema similar en la proyección predeterminada. Mientras que `wrld_simpl` se ha extendido colocando dos coordenadas ficticias en el este y oeste del polo sur, este conjunto de datos no las tiene.

Tenemos que mirar cuidadosamente para entender lo que está sucediendo, pero esto se está solapando/sobreponiendo con sigo mismo y está tan cerca del límite sur que apenas lo notamos.


```{r no-pole}
plot(0, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-180, -110), ylim = c(-90, -60))

rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = "darkred", lwd = 4, lty = 2)

maps::map(add = TRUE,col = "grey", fill = TRUE)

maps::map(col = "grey", fill = TRUE)


mpmerc <- m
pxy <- rgdal::project(lonlat, "+proj=merc +datum=WGS84")
mpmerc$x <- pxy[,1]
mpmerc$y <- pxy[,2]
mpmerc$range <- c(range(mpmerc$x,na.rm = TRUE), range(mpmerc$y, na.rm = TRUE))
mpmerc$range

## the catastrophe made a little clearer 
plot(0, xlim = range(mpmerc$range[1:2]), ylim = c(mpmerc$range[1], 0))
maps::map(mpmerc,  fill = TRUE, col = "grey", add = TRUE)


```

## SOmap

El paquete `SOmap` está diseñado para resolver la mayoría de estos problemas y proporcionar una forma sencilla de crear buenos mapas de la Antártida y el océano austral. Está enfocado principalmente en mapas en proyección estereográfica polar (aunque la función `SOmap_auto` extiende esto a otras proyecciones). `SOmap` no necesariamente te dará el mapa exacto que deseas en todas las circunstancias, pero la idea es que en la mayoría de los casos debería acercarte lo suficiente, y si es necesario, puedes realizar modificaciones para adaptarlo a tus necesidades exactas.

Por favor tener en cuenta que `SOmap` aún está en desarrollo, por lo que su funcionalidad (parámetros de función y/o comportamiento) puede cambiar.

Por defecto, `SOmap`  funciona con gráficos base (y funciones asociadas a paquetes como `raster` y `sp`). También es posible trabajar con gráficos basados en `ggplot2`, como se describe a continuación.

Comienza instalando el paquete `SOmap` si es que aún no lo has hecho:
```{somap_install eval = FALSE}
remotes::install_github("AustralianAntarcticDivision/SOmap")

```

Luego carga el paquete:

```{r somap_init, cache = FALSE}
library(SOmap)
## también define un mapa de colores para usar en algunos ejemplos
my_cmap <- colorRampPalette(c("#4D4140", "#596F7E", "#168B98",
                              "#ED5B67", "#E27766", "#DAAD50", "#EAC3A6"))(51)
```

```{r somap_pkgs, echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE}
## asegúrate de que estos estén cargados; las llamadas a library a continuación están en la memoria caché y es posible que no se evalúen en cada ejecución
library(sp)
library(raster)
library(ggplot2)
```

### Mapas circumpolares

Un mapa circumpolar básico en proyección estereográfica polar:


```{r somap1}
SOmap()
```

`SOmanagement()` proporciona una serie de capas contextuales como límites de AMP y zonas de gestión.
```{r somap2}
SOmap(trim = -40) ##traza hasta 40S
## agrega la capa de gestión de zonas económicas exclusivas (exclusive economic zones - EEZ)
SOmanagement(eez = TRUE)
```

#### Adding points

```{r somap_pts1}
## algunos datos de longitud/latitud
library(sp)
my_points_ll <- data.frame(lon = seq(0, 350, by = 10), lat = -55, z = runif(36))
coordinates(my_points_ll) <- c("lon", "lat")
projection(my_points_ll) <- "+proj=longlat +datum=WGS84"
```

Nuestros datos deben reproyectarse para que coincidan con nuestro mapa antes de trazarlos. La función `SOproj` hace esto:

```{r somap_pts2}
## reproject to our SOmap projection
my_points <- SOproj(my_points_ll)
## and plot
SOmap()
plot(my_points, col = "blue", add = TRUE)
```

O puedes usar `SOplot` para proyectar y trazar el mapa en un solo paso:

```{r somap_pts3}
SOmap()
SOplot(my_points_ll, col = "blue")
```

#### Agrgar capaz raster

Primero construyamos algunos datos raster artificiales (en espacio de longitud-latitud) con fines de demostración:

```{r somap_raster1, message = FALSE, warning = FALSE}
library(raster)
temp <- as.data.frame(expand.grid(lon = seq(100, 140, by = 0.25),
                                  lat = seq(-65, -45, by = 0.1)))
temp$val <- sqrt((temp$lon - 120)^2/3 + (temp$lat - -40)^2/5)
## creando objeto raster
xr <- rasterFromXYZ(temp)
projection(xr) <- "+proj=longlat +datum=WGS84"
```

`SOplot` reproyecta esto por nosotros:

```{r somap_raster2}
SOmap()
SOplot(xr)
```

La leyenda no coincide con el resto del mapa. Podemos usar `SOleg` para solucionar eso:

```{r somap_raster3}
## dibuja mapa base
SOmap()
## agrega nuestro raster
SOplot(xr, legend = FALSE, col = my_cmap)
## agrega la leyenda
SOleg(xr, position = "topright", col = my_cmap, ticks = 6,
      type = "continuous", label = "My variable")
```

Bueno, eso funcionó, pero claramente las etiquetas necesitan ser ordenadas. La forma más fácil es probablemente configurar el número de decimales en los valores de etiqueta a través del parámetro  `rnd`:


```{r somap_raster4rnd}
SOmap()
SOplot(xr, legend = FALSE, col = my_cmap)
SOleg(xr, position = "topright", col = my_cmap, ticks = 6, rnd = 2,
      type = "continuous", label = "My variable")
```

Alternativamente, podríamos establecer explícitamente el rango de colores y las etiquetas.
```{r somap_raster4}
## dibuja mapa base
SOmap()
## agregar nuestro raster, controlando el rango de colores para abarcar los valores de 0 a 30
colour_breaks <- seq(0, 30, length.out = length(my_cmap) + 1)
SOplot(xr, legend = FALSE, col = my_cmap, breaks = colour_breaks)
## agregar la leyenda, controlando nuevamente el rango de colores
label_breaks <- seq(0, 30, length.out = 7)
SOleg(position = "topright", col = my_cmap, breaks = label_breaks,
      type = "continuous", label = "My variable")
```

Ten en cuenta que si *no* queremos mostrar la leyenda batimétrica, podemos tener problemas:
```{r somap_legend1}
SOmap(bathy_legend = FALSE) ## suprimir la leyenda batimétrica
SOleg(position = "topright", col = my_cmap, breaks = label_breaks,
      type = "continuous", label = "My variable")
```

La leyenda se ha cortado porque el diseño no ha dejado suficiente espacio alrededor del mapa para la leyenda curvada. Actualmente, la mejor solución probablemente sea generar el objeto `SOmap` *con* la leyenda batimétrica, pero luego eliminarla antes de trazarla

```{r somap_legend2}
temp <- SOmap()
temp$bathy_legend <- NULL ## suprimir la leyenda batimétrica
plot(temp)
SOleg(position = "topright", col = my_cmap, breaks = label_breaks,
      type = "continuous", label = "My variable")
```


Multiple rasters:

```{r somap_raster5}
xr2 <- raster::shift(xr, -70) ## agrega desplazamiento en longitud
SOmap()
SOplot(xr, legend = FALSE, col = my_cmap)
SOplot(xr2, legend = FALSE, col = my_cmap)
```


### Mapas no circumpolares
tomará tus datos de entrada y hará una suposición sobre la proyección y la extensión adecuadas para usar. Ten en cuenta que esto no siempre adivinará la *mejor* proyección y extensión, por lo que debes verlo como un punto de partida desde el cual puedes generar un mapa según tus requisitos exactos.

Usa los datos de seguimiento de elefantes marinos incluidos en el paquete como ejemplo:
```{r soauto1}
ellie <- SOmap_data$mirounga_leonina
## construir y trazar el mapa
SOmap_auto(ellie$lon, ellie$lat)
```

Un mapa en blanco simple para usar de base
```{r soauto2}
SOmap_auto(ellie$lon, ellie$lat, input_points = FALSE, input_lines = FALSE)
```

Puedes pasar un raster como dato de entrada, pero ten en cuenta que no trazará el raster (utiliza su extensión para inferir una extensión adecuada para el mapa):
```{r soauto3}
SOmap_auto(xr)
```

Pero podemos agregar el raster si lo deseamos:
```{r soauto4}
SOmap_auto(xr)
SOplot(xr, col = my_cmap)
```

Podemos forzar una proyección de interés:

```{r soauto5}
SOmap_auto(xr, target = "laea", centre_lon = 147, centre_lat = -42)
SOplot(xr, col = my_cmap)
```

Lo mismo, pero proporcionando una cadena proj4 completa al parámetro `target`:

```{r soauto6}
SOmap_auto(xr, target = "+proj=laea +lat_0=-42 +lon_0=147")
SOplot(xr, col = my_cmap)
```

Consulta el tutorial de Somap_auto [the SOmap_auto vignette](https://australianantarcticdivision.github.io/SOmap/articles/many-automap-examples.html) para más ejemplos.


### Trazando mapas usando ggplot2

Las funciones `SOmap` y `SOmap_auto` hacen mapas usando un gráfico base. Si te sientes más como usando `ggplot2`, también es posible. La función `SOgg` toma un objeto creado por una de esas funciones (usando gráficos base) y lo convierte para usar gráficos `ggplot2`. Al igual que con otras funciones `SOmap` devuelve un objeto (de clase `SOmap_gg` o `SOmap_auto_gg`) que contiene toda la información necesaria para generar el mapa. Imprimir o trazar este objeto provocará que construya un objeto ggplot. Imprimir o trazar ese objeto hará que se dibuje en el dispositivo gráfico, al igual que cualquier otro objeto `ggplot`.

```{r somap3}
myplot <- SOmap()
myplotgg <- SOgg(myplot) ## crea un objeto SOmap_gg
class(myplotgg)
my_ggplot <- plot(myplotgg) ## crea un objeto ggplot
class(my_ggplot)
plot(my_ggplot) ## tráza el mapa
```

O en un solo paso (esto hará que `myplot` se convierta en el formato gg interno de `SOmap`, luego se construirá un objeto `ggplot` a partir de eso, y ese objeto se trazará):

```{r somap4}
SOgg(myplot)
```

### Modificar objetos de mapa (uso avanzado)

El objetivo de `SOmap` es hacer que sea bastante fácil producir un mapa bastante bueno que sea adecuado para la mayoría de los requisitos de mapeo. Nunca será posible producir automáticamente un mapa *perfecto en todas las circunstancias*, pero el objetivo es tener una forma fácil que se acerque a la perfección.

Esta sección describe algunos enfoques para modificar un mapa y adaptarlo a tus necesidades particulares. Ten en cuenta que, dependiendo de las modificaciones necesarias, esto podría llevarte bastante cerca del borde del desarrollo de `SOmap`. En particular, cualquier cosa que requiera modificar la estructura interna de un objeto `SOmap` puede cambiar en el futuro (con suerte, haremos que este tipo de cosas sea más fácil, pero aún no llegamos a eso).

#### Modificar mapas con gráficos base

Las funciones `SOmap()`, `SOmanagement()`, `SOmap_auto()` devuelven/arrojan un objeto de clase `SOmap`, `SOmap_management`, or `SOmap_auto`. Estos objetos contienen todos los datos e instrucciones de trazado necesarios para dibujar el mapa. Funciones `print()` o `plot()` en uno de estos objetos hará que se ejecute ese código y se dibuje el objeto en el dispositivo gráfico actual. Por lo tanto, usando `SOmap()` directamente *sin* asignar el resultado a una variable hará que aparezca en el dispositivo gráfico, porque el objeto devuelto se imprime en la consola (y, por lo tanto, activa el método `print`). Pero también puedes asignar el resultado a una variable, por ejemplo, `myplot <- SOmap()`, y luego trazar explícitamente el objeto con `plot(myplot)`. La ventaja de esto es que puedes manipular el objeto `myplot` para realizar cambios en el mapa antes de trazarlo.

Ten en cuenta que esto probablemente sea frágil. ¡Procede bajo tu propio riesgo!
```{r somap2a}
mymap <- SOmap()
names(mymap)
```

El objeto contiene un componente de tipo `plot_sequence`, que define el orden en el que se dibuja cada parte del mapa. Los otros componentes del objeto contienen el código necesario para dibujar cada parte. Tomemos, por ejemplo, el componente de hielo (esto son las plataformas de hielo, lenguas de glaciar, etc.). Este es una lista (en este caso, con un solo elemento). Cada elemento de la lista especifica una función para ejecutar junto con los argumentos que se le pasarán:

```{r somap2b}
str(mymap$ice)
```

Podemos modificar la función y/o sus argumentos:

```{r somap2c}
mymap$ice[[1]]$plotargs$col <- "green"
```

```{r somap2d}
plot(mymap)
```

Podemos eliminar componentes completos:
```{r somap2e}
temp <- mymap
temp$coastline <- NULL
temp$ice <- NULL
plot(temp)
```

Pero ten en cuenta que algunos elementos son necesarios. En particular, la capa batimétrica actualmente no se puede eliminar porque el código que la dibuja también es el código que crea la página de trazado mediante `plot.new()`. El código a continuación fallaría si no hubiera ningún trazado existente. Si hubiera un trazado existente en el dispositivo gráfico, este código se ejecutaría pero daría resultados impredecibles porque se dibujaría encima del trazado previamente configurado:

```{r somap2f, eval = FALSE}
## código no ejecutado aquí
temp <- mymap
temp$bathy <- NULL
plot(temp)
```

Una forma de evitar esto sería simplemente reemplazar todos los valores de datos batimétricos por `NA`s. El código de trazado seguiría teniendo la extensión de la capa batimétrica que necesita para configurar el trazado, pero no se mostrarían datos:
```{r somap2h2}
temp <- mymap
## los datos batimétricos están en temp$bathy[[1]]$plotargs$x
## y es un ráster, así que podemos establecer sus valores en NA con
raster::values(temp$bathy[[1]]$plotargs$x) <- NA_real_
temp$bathy_legend <- NULL
plot(temp)

```

También podríamos reemplazar los datos batimétricos por otro objeto raster. Ten en cuenta que debemos tener cuidado con la extensión y la proyección de este ráster. Por ejemplo, reemplazar el ráster batimétrico por el ráster de hielo (que tiene la misma proyección estereográfica polar pero una extensión más pequeña) da como resultado:

```{r somap2g}
temp <- mymap
temp$bathy[[1]]$plotargs$x <- ice
temp$bathy_legend <- NULL
plot(temp)
```

Está cortado porque la extensión del ráster de hielo se está utilizando para establecer la extensión del trazado. Pero si extendemos el ráster de hielo para que coincida con la extensión del mapa:
```{r somap2h}
temp <- mymap
temp$bathy[[1]]$plotargs$x <- raster::extend(ice, mymap$target)
temp$bathy_legend <- NULL
plot(temp)
```

#### Modificnado mapas con ggplot

Podemos modificar mapas basados en `ggplot2` en dos niveles

##### Modificando el objeto `ggplot`.

Recuerda que imprimir o trazar un objeto `SOmap_gg` produce un objeto `ggplot`. Este puede ser modificado agregando, por ejemplo, capas o temas, como cualquier otro objeto `ggplot`. Asegúrate de cargar la biblioteca `ggplot2` ahora que estamos utilizando funciones de `ggplot2` directamente.

```{r somap6, message = FALSE, warning = FALSE}
library(ggplot2)
my_ggplot + geom_point(data = as.data.frame(my_points), aes(lon, lat, colour = z), size = 3) +
  scale_colour_distiller(palette = "Spectral")
```


Varios rásters o varios conjuntos de puntos se vuelven complicados si están en diferentes escalas, porque `ggplot2` solo está diseñado para trabajar con una sola escala de color por tipo de geometría. Puedes probar suerte con los paquetes `ggnewscale` o `relayer`, aunque ambos están en una etapa experimental de desarrollo.

```{r somap5f, warning = FALSE, message = FALSE}
## remotes::install_github("clauswilke/relayer")
library(relayer)
plot(SOgg(SOmap(straight = TRUE))) +
  rename_geom_aes(geom_raster(data = as.data.frame(SOproj(xr), xy = TRUE),
                  aes(x = x, y = y, fill2 = val)), new_aes = c(fill = "fill2")) +
  scale_fill_gradientn(aesthetics = "fill2", colors = my_cmap, na.value = NA,
                       name = "My variable", guide = "legend")
```

```{r somap5g, warning = FALSE, message = FALSE}
## remotes::install_github("eliocamp/ggnewscale")
library(ggnewscale)
plot(SOgg(SOmap(straight = TRUE))) +
  new_scale_fill() +
  geom_raster(data = as.data.frame(SOproj(xr), xy = TRUE),
                  aes(x = x, y = y, fill = val)) +
  scale_fill_gradientn(colors = my_cmap, na.value = NA, name = "My variable")
```

##### Modicandoe el objecto `SOmap_gg`

El objeto `SOmap_gg` tiene una estructura similar al objeto `SOmap`, en el sentido de que contienen todos los datos e instrucciones de trazado necesarios para dibujar el mapa:
```{r somap5}
names(myplotgg)
```

sin embargo, n lugar de funciones de gráficos base, los objetos `SOmap_gg` utilizan llamadas a `ggplot2`, por ejemplo:

```{r somap5a}
myplotgg$ice[[1]]$plotfun
```

Podemos modificar estas funciones y/o argumentos de manera similar a los objetos `SOmap`.

```{r somap5b}
myplotgg$ice[[1]]$plotargs$fill <- "green"
```

```{r somap5c}
plot(myplotgg)
```

O eliminar la capa de ráster batimétrico:

```{r somap5d}
temp <- myplotgg
temp$bathy <- NULL
temp$bathy_legend <- NULL
plot(temp)
```

O reemplazarlo por un ráster diferente (usaremos el ráster de hielo como ejemplo):

```{r somap5e, warning = FALSE, message = FALSE}
temp <- myplotgg
## convertir el ráster de hielo a un data.frame adecuado
ice_raster_as_df <- raster::as.data.frame(SOproj(ice), xy = TRUE)
names(ice_raster_as_df)[3] <- "ice"
## agregar esto a nuestro objeto en lugar de baty
temp$bathy <- SO_plotter(plotfun = "ggplot2::geom_raster",
                         plotargs = list(data = ice_raster_as_df,
                                         mapping = aes_string(fill = "ice"))
)
## cambia la escala de color
temp$scale_fill[[1]]$plotargs <- list(colours = my_cmap, na.value = "#FFFFFF00", guide = FALSE)
## remueve leyenda batrimétrica
temp$bathy_legend <- NULL
plot(temp)
```

### Otros detalles que tener en cuenta en SOmap

Algunas cosas adicionales que vale la pena mencionar.

#### Impresión automática y bucles `for` (for-loops)

Si escribes directamente el nombre de una variable/objeto en la consola, esto activa automáticamente el método `print` de ese objeto. Escribir `SOmap()` en la consola devuelve un objeto de clase `SOmap`, y como esto ocurre en la consola, se llama al método `print` de ese objeto, lo que provoca que el mapa se trace en el dispositivo gráfico actual.

Sin embargo, R desactiva la impresión automática dentro de bucles `for` y funciones. Entonces, este código:
```{r eval = FALSE}
for (i in 1:5) {
  SOmap_auto()
}
```

no producirá nada, porque el método `print` nunca se llama. Si estás generando mapas usando bucles, deberás llamar explícitamente al método `print`:
```{r eval = FALSE}
for (i in 1:5) {
  print(SOmap_auto())
}
```

## Datos de soporte para crear mapas

Cuando se construyen mapas, comúnmente queremos mostrar características como frentes oceanográficos, extensión de hielo, línea de costa, nombres de lugares y límites de AMP (Áreas Marinas Protegidas). Hay algunas fuentes de estos datos:

- agunas capaz estan incluidas en `SOmap`, consultar objeto `SOmap::SOmap_data`
- `antanym` proporciona acceso al Gazetteer Compuesto de la SCAR (Comité Científico de Investigación Antártica) de nombres de lugares
- El paquete`quantarcticR` provee acceso a las capas de datos de [Quantarctica](http://quantarctica.npolar.no/)

### quantarcticR

Ten en cuenta que este paquete aún está en desarrollo, por lo que el uso que se muestra aquí podría cambiar en versiones posteriores. Instálalo si es necesario:
```{r eval = FALSE}
## remotes::install_github("SCAR-sandpit/quantarcticR")
```

Ejemplo de como usar quantarcticR:

```{r qR1}
library(quantarcticR)
```

```{r qR1hidden, echo = FALSE, results = "asis", cache = FALSE}
if (grepl("ben_ray", tempdir())) {
  quantarcticR::qa_cache_dir("c:/data/Quantarctica3")
}
```

```{r qR1b}
ds <- qa_datasets() ## todas las capas disponibles
head(ds)

## más informació acerca de una capa de interés
my_layer <- qa_dataset("Median sea ice extent 1981-2010")
my_layer

## obtener los datos reales de esa capa
layer_data <- qa_get(my_layer)

## gráficalo
plot(layer_data[layer_data$MONTH == "October", ])

## o añadirla a un SOmap
SOmap(trim = -50, border_width = 0.5)
SOplot(layer_data[layer_data$MONTH == "October", ], col = "red")


```

### antanym

Consulta el artículo de visión general. [overview](overview.html).
